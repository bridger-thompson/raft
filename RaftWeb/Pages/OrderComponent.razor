@using RaftWeb.Models;
@using RaftWeb.Services;
@inject OrderService orderService;
@inject BalanceService balanceService;
@inject ProductService productService;
@inject RaftService service;

<div class="border rounded shadow-sm mb-2">
  @if (Cart is not null)
  {
    <div class="row my-2">
      <div class="col ps-3">
        <div class="fw-bold">Placed By:</div>
        <div>@Cart.Username</div>
        <div>Status: @Status</div>
      </div>
      <div class="col">
        <div class="fw-bold">Items:</div>
        <div class="list-group">
          @foreach (var item in Cart.Items)
          {
            <li class="list-group-item d-flex justify-content-between lh-sm">
              <div>
                <div class="fw-bold">@item.Name</div>
                <div class="text-muted small">Quantity: @item.Quantity</div>
              </div>
              <span>@item.Cost.ToString("C")</span>
            </li>
          }
        </div>
      </div>
      <div class="col text-center">
        <div class="fw-bold">Total (USD): @TotalPrice?.ToString("C")</div>
        <div class="mt-2">
          <button class="btn btn-primary" @onclick="() => Process()">Process</button>
        </div>
      </div>
    </div>
  }
</div>


@code {
  [Parameter]
  public Guid OrderId { get; set; }

  [Parameter]
  public EventCallback OnOrderProcessed { get; set; }

  private Cart? Cart;
  private decimal? TotalPrice => Cart?.Items.Sum(item => item.Cost * (item.Quantity ?? 1));
  private string Status = string.Empty;
  private decimal? usersBalance;
  private decimal? vendorBalance;
  private Data lastVendorBalanceData;
  private Data lastBalanceData;

  protected override async Task OnInitializedAsync()
  {
    await Load();
  }

  private async Task Load()
  {
    (Cart, Status) = await orderService.GetOrder(OrderId);
    if (Cart is not null)
    {
      var balanceResult = await service.StrongGet(balanceService.GetKey(Cart.Username));
      lastBalanceData = balanceResult;
      usersBalance = balanceService.GetBalance(balanceResult);


      var vendorResult = await service.StrongGet(balanceService.GetKey("vendor"));
      lastVendorBalanceData = vendorResult;
      vendorBalance = balanceService.GetBalance(vendorResult);
    }
  }

  private async Task Process()
  {
    if (Cart is not null && TotalPrice is not null)
    {
      // balance of the user is reduced by that total price, continuing to retry as long as the new balance is non-negative
      // (undo is to replace the price)
      await balanceService.Withdraw(usersBalance, TotalPrice ?? 0, Cart.Username, lastBalanceData);

      // stock of each product is reduced, continuing to retry as long as the resulting stock is non-negative
      // (undo is to increase the stock by the same amount)
      foreach (var item in Cart.Items)
      {
        for (int i = 0; i < item.Quantity; i++)
        {
          var productResult = await service.StrongGet(productService.GetKey(item));
          var quantity = productService.LoadQuantity(productResult);
          if (quantity is not null && quantity > 0)
          {
            await productService.DecreaseQuantity(productService.GetKey(item), quantity, productResult);
          }
        }
      }

      // balance of the vendor (username="vendor") is increased by the total price, continuing to retry until successful
      // (undo is to reduce the amount)
      await balanceService.Deposit(vendorBalance, TotalPrice ?? 0, "vendor", lastVendorBalanceData);

      // generate a unique processor id and change the order status from pending to "processed-by <processor-id>"
      // (fail if we see that the order was processed by some other processor id; undo for this would be to mark the status as
      // pending-- - which would only happen conditioned on the value still having our processor - id)
      var processorId = Guid.NewGuid();
      var status = $"Processed By {processorId}";
      await orderService.UpdateOrderStatus(OrderId, status);

      // remove order id from pending-orders (continue to retry this until a timeout is reached)
      await orderService.RemovePendingOrder(OrderId);
      await OnOrderProcessed.InvokeAsync();
    }
  }
}
